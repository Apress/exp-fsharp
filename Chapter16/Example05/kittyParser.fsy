%{
open KittyAst
%}

// The start token becomes a parser function in the compiled code: 
%start start

// These are the terminal tokens of the grammar along with the types of
// the data carried by each token:
%token <string> ID
%token <int> INT
%token PLUS MINUS TIMES LPAREN RPAREN IF THEN ELSE %token WHILE DO BEGIN END PRINT SEMI ASSIGN EOF

// lowest precedence comes first
%left PLUS MINUS
%left TIMES

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type <prog> start

%%

start: Prog                   { $1 }

Prog: StmtList                { Prog (List.rev $1) }

Expr: ID                      { Val $1 }
    | INT                     { Int $1 }
    | Expr PLUS Expr          { Plus ($1, $3) }
    | Expr MINUS Expr         { Minus ($1, $3) }
    | LPAREN Expr RPAREN      { $2 }

Stmt: ID ASSIGN Expr              { Assign ($1, $3) }
    | WHILE Expr DO Stmt          { While ($2, $4) }
    | BEGIN StmtList END          { Seq (List.rev $2) }
    | IF Expr THEN Stmt           { IfThen ($2, $4) }
    | IF Expr THEN Stmt ELSE Stmt { IfThenElse ($2, $4, $6) }
    | PRINT Expr                  { Print $2 }

StmtList: 
    | Stmt               { [$1] }
    | StmtList SEMI Stmt { $3 :: $1  }
